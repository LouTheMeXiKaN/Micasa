const express = require('express');
const { body, validationResult, param } = require('express-validator');
const multer = require('multer');
const path = require('path');
const fs = require('fs').promises;
const { PrismaClient } = require('@prisma/client');
const { authenticateToken } = require('../middleware/auth');

const router = express.Router();
const prisma = new PrismaClient();

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: async (req, file, cb) => {
    const uploadDir = path.join(__dirname, '../uploads/avatars');
    try {
      await fs.mkdir(uploadDir, { recursive: true });
    } catch (error) {
      console.error('Error creating upload directory:', error);
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    // Generate unique filename with user ID and timestamp
    const ext = path.extname(file.originalname);
    const filename = `${req.userId}-${Date.now()}${ext}`;
    cb(null, filename);
  }
});

// File filter for images only
const fileFilter = (req, file, cb) => {
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only JPEG, PNG, GIF, and WebP are allowed.'), false);
  }
};

const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB limit
  }
});

// Helper function to format user profile response
const formatUserProfile = (user, isOwnProfile = false) => {
  const profile = {
    user_id: user.id,
    username: user.username,
    profile_picture_url: user.profilePictureUrl,
    bio: user.bio,
    instagram_handle: user.instagramHandle,
    personal_website_url: user.personalWebsiteUrl,
  };

  // Add private fields only for own profile
  if (isOwnProfile) {
    profile.email = user.email;
    profile.phone_number = user.phoneNumber;
    profile.is_phone_verified = user.isPhoneVerified;
    profile.has_hyperwallet_account = false; // TODO: Implement Hyperwallet integration
    profile.is_username_autogenerated = user.isUsernameAutogenerated;
    profile.privacy_show_upcoming_events = user.privacyShowUpcomingEvents;
    profile.privacy_show_past_events = user.privacyShowPastEvents;
    profile.privacy_past_events_include_hosted = user.privacyPastEventsIncludeHosted;
    profile.privacy_past_events_include_collaborated = user.privacyPastEventsIncludeCollaborated;
    profile.privacy_past_events_include_attended = user.privacyPastEventsIncludeAttended;
  }

  return profile;
};

// Validation rules for profile updates
const updateProfileValidation = [
  body('username')
    .optional()
    .trim()
    .isLength({ min: 2, max: 30 })
    .withMessage('Username must be between 2 and 30 characters')
    .matches(/^[a-zA-Z0-9_]+$/)
    .withMessage('Username can only contain letters, numbers, and underscores'),
  
  body('phone_number')
    .optional()
    .trim()
    .matches(/^\+?[1-9]\d{1,14}$/)
    .withMessage('Phone number must be in valid international format'),
  
  body('bio')
    .optional()
    .trim()
    .isLength({ max: 500 })
    .withMessage('Bio cannot exceed 500 characters'),
  
  body('instagram_handle')
    .optional()
    .trim()
    .matches(/^[a-zA-Z0-9_.]+$/)
    .withMessage('Instagram handle can only contain letters, numbers, dots, and underscores')
    .isLength({ max: 30 })
    .withMessage('Instagram handle cannot exceed 30 characters'),
  
  body('personal_website_url')
    .optional()
    .trim()
    .isURL()
    .withMessage('Personal website must be a valid URL'),
  
  body('privacy_show_upcoming_events')
    .optional()
    .isBoolean()
    .withMessage('privacy_show_upcoming_events must be boolean'),
  
  body('privacy_show_past_events')
    .optional()
    .isBoolean()
    .withMessage('privacy_show_past_events must be boolean'),
  
  body('privacy_past_events_include_hosted')
    .optional()
    .isBoolean()
    .withMessage('privacy_past_events_include_hosted must be boolean'),
  
  body('privacy_past_events_include_collaborated')
    .optional()
    .isBoolean()
    .withMessage('privacy_past_events_include_collaborated must be boolean'),
  
  body('privacy_past_events_include_attended')
    .optional()
    .isBoolean()
    .withMessage('privacy_past_events_include_attended must be boolean'),
];

// GET /users/me - Get authenticated user's profile
router.get('/me', authenticateToken, async (req, res) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id: req.userId },
    });

    if (!user) {
      return res.status(404).json({
        error_code: 'USER_NOT_FOUND',
        message: 'User profile could not be retrieved'
      });
    }

    const profile = formatUserProfile(user, true);
    res.json(profile);
  } catch (error) {
    console.error('Error fetching user profile:', error);
    res.status(500).json({
      error_code: 'INTERNAL_ERROR',
      message: 'Failed to retrieve user profile'
    });
  }
});

// PUT /users/me - Update authenticated user's profile
router.put('/me', authenticateToken, updateProfileValidation, async (req, res) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error_code: 'VALIDATION_FAILED',
        message: 'Invalid input data',
        details: errors.array()
      });
    }

    const updateData = {};
    const allowedFields = {
      username: 'username',
      phone_number: 'phoneNumber',
      profile_picture_url: 'profilePictureUrl',
      bio: 'bio',
      instagram_handle: 'instagramHandle',
      personal_website_url: 'personalWebsiteUrl',
      privacy_show_upcoming_events: 'privacyShowUpcomingEvents',
      privacy_show_past_events: 'privacyShowPastEvents',
      privacy_past_events_include_hosted: 'privacyPastEventsIncludeHosted',
      privacy_past_events_include_collaborated: 'privacyPastEventsIncludeCollaborated',
      privacy_past_events_include_attended: 'privacyPastEventsIncludeAttended',
    };

    // Map request fields to Prisma field names
    for (const [reqField, prismaField] of Object.entries(allowedFields)) {
      if (req.body[reqField] !== undefined) {
        updateData[prismaField] = req.body[reqField];
      }
    }

    // If username is being updated, mark it as no longer autogenerated
    if (updateData.username) {
      updateData.isUsernameAutogenerated = false;
    }

    // Check if username is already taken (if being updated)
    if (updateData.username) {
      const existingUser = await prisma.user.findFirst({
        where: {
          username: updateData.username,
          id: { not: req.userId }
        }
      });

      if (existingUser) {
        return res.status(409).json({
          error_code: 'USERNAME_TAKEN',
          message: 'This username is already in use'
        });
      }
    }

    // Check if phone number is already taken (if being updated)
    if (updateData.phoneNumber) {
      const existingUser = await prisma.user.findFirst({
        where: {
          phoneNumber: updateData.phoneNumber,
          id: { not: req.userId }
        }
      });

      if (existingUser) {
        return res.status(409).json({
          error_code: 'PHONE_NUMBER_TAKEN',
          message: 'This phone number is already in use'
        });
      }

      // Reset phone verification if phone number changes
      updateData.isPhoneVerified = false;
      updateData.phoneOtp = null;
      updateData.phoneOtpExpiresAt = null;
    }

    // Update the user
    const updatedUser = await prisma.user.update({
      where: { id: req.userId },
      data: updateData,
    });

    const profile = formatUserProfile(updatedUser, true);
    res.json(profile);
  } catch (error) {
    console.error('Error updating user profile:', error);
    
    // Handle Prisma unique constraint errors
    if (error.code === 'P2002') {
      const field = error.meta?.target?.[0];
      return res.status(409).json({
        error_code: 'DUPLICATE_VALUE',
        message: `${field} is already in use`
      });
    }

    res.status(500).json({
      error_code: 'INTERNAL_ERROR',
      message: 'Failed to update user profile'
    });
  }
});

// GET /users/me/events - Get authenticated user's events
router.get('/me/events', authenticateToken, async (req, res) => {
  try {
    const { status, role } = req.query;
    const userId = req.userId;
    
    // Build where clause based on filters
    const whereClause = {
      hostUserId: userId // For now, only return events where user is host
    };
    
    // Add status filter
    const now = new Date();
    if (status === 'upcoming') {
      whereClause.startTime = { gte: now };
      whereClause.status = 'published';
    } else if (status === 'past') {
      whereClause.endTime = { lt: now };
    }
    
    // Fetch events from database
    const events = await prisma.event.findMany({
      where: whereClause,
      orderBy: {
        startTime: status === 'past' ? 'desc' : 'asc'
      }
    });
    
    // Format response
    const formattedEvents = events.map(event => ({
      event_id: event.id,
      host_user_id: event.hostUserId,
      title: event.title,
      description: event.description,
      cover_image_url: event.coverImageUrl,
      start_time: event.startTime.toISOString(),
      end_time: event.endTime.toISOString(),
      location_address: event.locationAddress,
      location_visibility: event.locationVisibility,
      pricing_model: event.pricingModel,
      price_fixed: event.priceFixed,
      guest_list_visibility: event.guestListVisibility,
      is_invite_only: event.isInviteOnly,
      max_capacity: event.maxCapacity,
      status: event.status,
      current_user_role: 'host' // User is always host for their own events
    }));
    
    res.json({
      events: formattedEvents,
      total_count: formattedEvents.length
    });
    
  } catch (error) {
    console.error('Error fetching user events:', error);
    res.status(500).json({
      error_code: 'INTERNAL_ERROR',
      message: 'Failed to retrieve user events'
    });
  }
});

// GET /users/:userId - Get public profile of a user
router.get('/:userId', [
  param('userId').isUUID().withMessage('Invalid user ID format')
], async (req, res) => {
  try {
    // Check for validation errors
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        error: 'Validation failed',
        message: 'Invalid user ID format',
        details: errors.array()
      });
    }

    const user = await prisma.user.findUnique({
      where: { id: req.params.userId },
    });

    if (!user) {
      return res.status(404).json({
        error_code: 'USER_NOT_FOUND',
        message: 'The requested user profile does not exist'
      });
    }

    // Return only public profile information
    const profile = formatUserProfile(user, false);
    res.json(profile);
  } catch (error) {
    console.error('Error fetching public user profile:', error);
    res.status(500).json({
      error_code: 'INTERNAL_ERROR',
      message: 'Failed to retrieve user profile'
    });
  }
});

// POST /users/me/avatar - Upload profile picture
router.post('/me/avatar', authenticateToken, (req, res) => {
  upload.single('file')(req, res, async (err) => {
    try {
      if (err) {
        if (err instanceof multer.MulterError) {
          if (err.code === 'LIMIT_FILE_SIZE') {
            return res.status(400).json({
              error_code: 'FILE_TOO_LARGE',
              message: 'Profile picture must be smaller than 5MB'
            });
          }
        }
        return res.status(400).json({
          error_code: 'UPLOAD_FAILED',
          message: err.message || 'Failed to upload profile picture'
        });
      }

      if (!req.file) {
        return res.status(400).json({
          error_code: 'NO_FILE_PROVIDED',
          message: 'Please select a profile picture to upload'
        });
      }

      // Construct the URL for the uploaded file
      // In production, this would be a CDN URL
      const fileUrl = `${req.protocol}://${req.get('host')}/uploads/avatars/${req.file.filename}`;

      // Update user's profile picture URL in database
      const updatedUser = await prisma.user.update({
        where: { id: req.userId },
        data: { profilePictureUrl: fileUrl },
      });

      res.json({
        message: 'Profile picture uploaded successfully',
        profile_picture_url: fileUrl
      });
    } catch (error) {
      console.error('Error uploading profile picture:', error);
      
      // Clean up uploaded file if database update fails
      if (req.file) {
        try {
          await fs.unlink(req.file.path);
        } catch (unlinkError) {
          console.error('Error cleaning up uploaded file:', unlinkError);
        }
      }

      res.status(500).json({
        error_code: 'INTERNAL_ERROR',
        message: 'Failed to upload profile picture'
      });
    }
  });
});

// GET /users/me/applications - Get user's applications
router.get('/me/applications', authenticateToken, async (req, res) => {
  try {
    const userId = req.userId;

    // Get all applications for the authenticated user
    const applications = await prisma.application.findMany({
      where: { userId: userId },
      include: {
        position: {
          include: {
            event: {
              select: {
                id: true,
                title: true,
                startTime: true,
                endTime: true,
                hostUserId: true,
                host: {
                  select: {
                    id: true,
                    username: true
                  }
                }
              }
            }
          }
        }
      },
      orderBy: {
        appliedAt: 'desc'
      }
    });

    // Format the response
    const formattedApplications = applications.map(app => ({
      application_id: app.id,
      status: app.status,
      applied_at: app.appliedAt.toISOString(),
      message: app.message,
      position: {
        position_id: app.position.id,
        role_title: app.position.roleTitle,
        profit_share_percentage: app.position.profitSharePercentage ? 
          parseFloat(app.position.profitSharePercentage.toString()) : null,
        status: app.position.status
      },
      event: {
        event_id: app.position.event.id,
        title: app.position.event.title,
        start_time: app.position.event.startTime.toISOString(),
        end_time: app.position.event.endTime.toISOString(),
        host: {
          user_id: app.position.event.host.id,
          username: app.position.event.host.username
        }
      }
    }));

    res.json(formattedApplications);

  } catch (error) {
    console.error('Error fetching user applications:', error);
    res.status(500).json({
      error_code: 'INTERNAL_ERROR',
      message: 'Failed to retrieve applications'
    });
  }
});

module.exports = router;