const express = require('express');
const { PrismaClient } = require('@prisma/client');
const { generateToken } = require('../utils/jwt');
const { hashPassword, comparePassword } = require('../utils/password');
const { authenticateToken } = require('../middleware/auth');
const { generateOTP, getOTPExpiration, validateOTP } = require('../utils/otp');
const { sendOTP, formatPhoneNumber } = require('../utils/sms');

const router = express.Router();
const prisma = new PrismaClient();

/**
 * Email validation regex
 */
const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

/**
 * Generate a unique username for auto-generated users
 */
function generateUsername() {
  const randomNumber = Math.floor(Math.random() * 1000000);
  return `user_${randomNumber}`;
}

/**
 * POST /auth/register
 * Register a new user with email and password
 */
router.post('/register', async (req, res) => {
  try {
    const { email, password } = req.body;

    // Validate input
    if (!email || !password) {
      return res.status(400).json({
        error_code: 'VALIDATION_ERROR',
        message: 'Email and password are required',
      });
    }

    // Validate email format
    if (!EMAIL_REGEX.test(email)) {
      return res.status(400).json({
        error_code: 'INVALID_EMAIL',
        message: 'Invalid email format',
      });
    }

    // Validate password length
    if (password.length < 8) {
      return res.status(400).json({
        error_code: 'WEAK_PASSWORD',
        message: 'Password must be at least 8 characters long',
      });
    }

    // Check if email already exists
    const existingUser = await prisma.user.findUnique({
      where: { email },
    });

    if (existingUser) {
      return res.status(409).json({
        error_code: 'EMAIL_EXISTS',
        message: 'Username or email is already taken',
      });
    }

    // Generate unique username
    let username = generateUsername();
    let usernameExists = true;
    let attempts = 0;

    while (usernameExists && attempts < 10) {
      const userWithUsername = await prisma.user.findUnique({
        where: { username },
      });
      
      if (!userWithUsername) {
        usernameExists = false;
      } else {
        username = generateUsername();
        attempts++;
      }
    }

    if (usernameExists) {
      return res.status(500).json({
        error_code: 'USERNAME_GENERATION_FAILED',
        message: 'Failed to generate unique username',
      });
    }

    // Hash password
    const hashedPassword = await hashPassword(password);

    // Create user
    const user = await prisma.user.create({
      data: {
        email,
        username,
        hashedPassword,
        isUsernameAutogenerated: true,
      },
      select: {
        id: true,
        email: true,
        username: true,
        phoneNumber: true,
        isPhoneVerified: true,
        profilePictureUrl: true,
        bio: true,
        instagramHandle: true,
        personalWebsiteUrl: true,
        isUsernameAutogenerated: true,
        privacyShowUpcomingEvents: true,
        privacyShowPastEvents: true,
        privacyPastEventsIncludeHosted: true,
        privacyPastEventsIncludeCollaborated: true,
        privacyPastEventsIncludeAttended: true,
      },
    });

    // Generate JWT token
    const token = generateToken(user.id);

    // Transform user to match UserProfile schema
    const userProfile = {
      user_id: user.id,
      email: user.email,
      username: user.username,
      phone_number: user.phoneNumber,
      is_phone_verified: user.isPhoneVerified,
      profile_picture_url: user.profilePictureUrl,
      bio: user.bio,
      instagram_handle: user.instagramHandle,
      personal_website_url: user.personalWebsiteUrl,
      has_hyperwallet_account: false, // Default for new users
      is_username_autogenerated: user.isUsernameAutogenerated,
      privacy_show_upcoming_events: user.privacyShowUpcomingEvents,
      privacy_show_past_events: user.privacyShowPastEvents,
      privacy_past_events_include_hosted: user.privacyPastEventsIncludeHosted,
      privacy_past_events_include_collaborated: user.privacyPastEventsIncludeCollaborated,
      privacy_past_events_include_attended: user.privacyPastEventsIncludeAttended,
    };

    res.status(201).json({
      token,
      user: userProfile,
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({
      error_code: 'INTERNAL_ERROR',
      message: 'An error occurred during registration',
    });
  }
});

/**
 * POST /auth/login
 * Log in with email and password
 */
router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    // Validate input
    if (!email || !password) {
      return res.status(400).json({
        error_code: 'VALIDATION_ERROR',
        message: 'Email and password are required',
      });
    }

    // Find user by email
    const user = await prisma.user.findUnique({
      where: { email },
      select: {
        id: true,
        email: true,
        username: true,
        hashedPassword: true,
        phoneNumber: true,
        isPhoneVerified: true,
        profilePictureUrl: true,
        bio: true,
        instagramHandle: true,
        personalWebsiteUrl: true,
        isUsernameAutogenerated: true,
        privacyShowUpcomingEvents: true,
        privacyShowPastEvents: true,
        privacyPastEventsIncludeHosted: true,
        privacyPastEventsIncludeCollaborated: true,
        privacyPastEventsIncludeAttended: true,
      },
    });

    if (!user) {
      return res.status(401).json({
        error_code: 'INVALID_CREDENTIALS',
        message: 'Invalid email or password',
      });
    }

    // Verify password
    const isPasswordValid = await comparePassword(password, user.hashedPassword);

    if (!isPasswordValid) {
      return res.status(401).json({
        error_code: 'INVALID_CREDENTIALS',
        message: 'Invalid email or password',
      });
    }

    // Generate JWT token
    const token = generateToken(user.id);

    // Transform user to match UserProfile schema (excluding hashedPassword)
    const userProfile = {
      user_id: user.id,
      email: user.email,
      username: user.username,
      phone_number: user.phoneNumber,
      is_phone_verified: user.isPhoneVerified,
      profile_picture_url: user.profilePictureUrl,
      bio: user.bio,
      instagram_handle: user.instagramHandle,
      personal_website_url: user.personalWebsiteUrl,
      has_hyperwallet_account: false, // Default for now
      is_username_autogenerated: user.isUsernameAutogenerated,
      privacy_show_upcoming_events: user.privacyShowUpcomingEvents,
      privacy_show_past_events: user.privacyShowPastEvents,
      privacy_past_events_include_hosted: user.privacyPastEventsIncludeHosted,
      privacy_past_events_include_collaborated: user.privacyPastEventsIncludeCollaborated,
      privacy_past_events_include_attended: user.privacyPastEventsIncludeAttended,
    };

    res.status(200).json({
      token,
      user: userProfile,
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({
      error_code: 'INTERNAL_ERROR',
      message: 'An error occurred during login',
    });
  }
});

/**
 * POST /auth/phone/send-otp
 * Send OTP to user's phone number for verification
 * Requires authentication
 */
router.post('/phone/send-otp', authenticateToken, async (req, res) => {
  try {
    const { phone_number } = req.body;

    // Validate input
    if (!phone_number) {
      return res.status(400).json({
        error_code: 'PHONE_REQUIRED',
        message: 'Phone number is required',
      });
    }

    // Basic phone validation (in production, use libphonenumber)
    const phoneRegex = /^[+]?[\d\s()-]+$/;
    if (!phoneRegex.test(phone_number) || phone_number.length < 10) {
      return res.status(400).json({
        error_code: 'INVALID_PHONE_FORMAT',
        message: 'Invalid phone number format',
      });
    }

    // Get user
    const user = await prisma.user.findUnique({
      where: { id: req.userId },
      select: {
        id: true,
        phoneNumber: true,
        isPhoneVerified: true,
      },
    });

    if (!user) {
      return res.status(404).json({
        error_code: 'USER_NOT_FOUND',
        message: 'User not found',
      });
    }

    // Check if phone is already verified
    if (user.isPhoneVerified && user.phoneNumber === phone_number) {
      return res.status(400).json({
        error_code: 'PHONE_ALREADY_VERIFIED',
        message: 'Phone number already verified',
      });
    }

    // Format phone number
    const formattedPhone = formatPhoneNumber(phone_number);

    // Generate OTP and expiration
    const otp = generateOTP();
    const otpExpiration = getOTPExpiration();

    // Update user with phone number and OTP
    await prisma.user.update({
      where: { id: req.userId },
      data: {
        phoneNumber: formattedPhone,
        phoneOtp: otp,
        phoneOtpExpiresAt: otpExpiration,
        isPhoneVerified: false, // Reset verification if phone number changed
      },
    });

    // Send OTP via SMS
    try {
      await sendOTP(formattedPhone, otp);
    } catch (smsError) {
      // Log error but don't expose internal details
      console.error('SMS send error:', smsError);
      
      // Clear OTP from database on SMS failure
      await prisma.user.update({
        where: { id: req.userId },
        data: {
          phoneOtp: null,
          phoneOtpExpiresAt: null,
        },
      });

      return res.status(500).json({
        error_code: 'SMS_SEND_FAILED',
        message: 'Failed to send verification code. Please try again.',
      });
    }

    res.status(201).json({
      message: 'Verification code sent successfully',
      phone_number: formattedPhone,
    });
  } catch (error) {
    console.error('Send OTP error:', error);
    res.status(500).json({
      error_code: 'INTERNAL_ERROR',
      message: 'An error occurred while sending verification code',
    });
  }
});

/**
 * POST /auth/phone/verify-otp
 * Verify OTP code and mark phone as verified
 * Requires authentication
 */
router.post('/phone/verify-otp', authenticateToken, async (req, res) => {
  try {
    const { otp } = req.body;

    // Validate input
    if (!otp) {
      return res.status(400).json({
        error_code: 'OTP_REQUIRED',
        message: 'OTP code is required',
      });
    }

    // Validate OTP format (6 digits)
    if (!/^\d{6}$/.test(otp)) {
      return res.status(400).json({
        error_code: 'INVALID_OTP',
        message: 'Invalid OTP format. Must be 6 digits.',
      });
    }

    // Get user with OTP data
    const user = await prisma.user.findUnique({
      where: { id: req.userId },
      select: {
        id: true,
        phoneNumber: true,
        phoneOtp: true,
        phoneOtpExpiresAt: true,
        isPhoneVerified: true,
      },
    });

    if (!user) {
      return res.status(404).json({
        error_code: 'USER_NOT_FOUND',
        message: 'User not found',
      });
    }

    // Check if phone is already verified
    if (user.isPhoneVerified) {
      return res.status(400).json({
        error_code: 'PHONE_ALREADY_VERIFIED',
        message: 'Phone number already verified',
      });
    }

    // Validate OTP
    const isValidOTP = validateOTP(user.phoneOtp, user.phoneOtpExpiresAt, otp);

    if (!isValidOTP) {
      // Check if OTP expired specifically
      if (user.phoneOtpExpiresAt && new Date() > user.phoneOtpExpiresAt) {
        return res.status(400).json({
          error_code: 'OTP_EXPIRED',
          message: 'Verification code has expired. Please request a new one.',
        });
      }

      return res.status(400).json({
        error_code: 'INVALID_OTP',
        message: 'Invalid verification code',
      });
    }

    // Mark phone as verified and clear OTP data
    const updatedUser = await prisma.user.update({
      where: { id: req.userId },
      data: {
        isPhoneVerified: true,
        phoneOtp: null,
        phoneOtpExpiresAt: null,
      },
      select: {
        id: true,
        phoneNumber: true,
        isPhoneVerified: true,
      },
    });

    res.status(200).json({
      message: 'Phone number verified successfully',
      user: updatedUser,
    });
  } catch (error) {
    console.error('Verify OTP error:', error);
    res.status(500).json({
      error_code: 'INTERNAL_ERROR',
      message: 'An error occurred while verifying phone number',
    });
  }
});

module.exports = router;